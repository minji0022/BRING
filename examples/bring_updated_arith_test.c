// -------------------------------------------------------------------------------
//  BRING이 제공하는 연산의 갱신 함수 in arith.c 예제 코드
//  
//  [ 지원 연산 ]
//  1. 덧셈 갱신 함수
//  2. 뺄셈 갱신 함수
//  3. 곱셈 갱신 함수
//  4. 제곱 갱신 함수
//  5. 모듈러 갱신 함수
// -------------------------------------------------------------------------------

#include "../bring_arith.h"

int main(){
    // -------------------------------------------------------------------------------
    // STEP 1. BIGINT SET: 16진수 문자열을 입력 받아 BIGINT 변수에 할당
    // -------------------------------------------------------------------------------
    // [ bi_set_by_string 주의사항 ]
    // - 입력: (할당할 BIGINT 구조체 더블 포인터, 부호 정보, 16진수 문자열, HEXDECIMAL)
    // - 출력: SUCCESS or ERROR CODE (int 변수로 반환값을 저장한 뒤, 에러 코드를 처리할 추가 코드 작성 필요)
    // -------------------------------------------------------------------------------    
    
    // 0. BIGINT 변수를 NULL로 초기화하여 선언
    BIGINT* num0 = NULL;
    BIGINT* num1 = NULL;

    // 1. BIGINT Set
    printf("=============  빅인티저 생성  ============== \n");
    int set_flag_0 = bi_set_by_string(&num0, NON_NEGATIVE, "1234567890abcdef1234567890abcdef1234567890abcdef", HEXDECIMAL);
    int set_flag_1 = bi_set_by_string(&num1, NON_NEGATIVE, "f2144faddc497d9ef6324912fd367840ee509a2032aedb1c0a890d133b45f596", HEXDECIMAL);
    
    // 1.1 유효하지 않은 입력이 발생할 경우 오류 메시지 출력 및 프로그램 종료
    if(set_flag_0 == INVALID_CHAR_ERROR) {
        puts("============= Input 1 : wrong! ==============");
        return 0;
    } 
    else if (set_flag_1 == INVALID_CHAR_ERROR) {
        puts("============== Input 2 : wrong! ==============");
        return 0;
    }

    // 1.2 예제 코드 확인을 위한 num0, num1 출력
    printf("A = ");   bi_print_bigint_hex(num0);      puts("");
    printf("B = ");   bi_print_bigint_hex(num1);      puts("");

    // 2. main 함수 제일 마지막에 Set해준 BIGINT 변수 삭제
    
    // -------------------------------------------------------------------------------
    // Function 1. 덧셈 갱신
    // -------------------------------------------------------------------------------
    // - 입력: (입력이자 덧셈 결과를 저장할 BIGINT 구조체 더블 포인터 num0, 입력 BIGINT 포인터 num1)
    // - 출력: SUCCESS or ERROR CODE (int 변수로 반환값을 저장한 뒤, 에러 코드를 처리할 추가 코드 작성 필요)
    // -------------------------------------------------------------------------------

    // 1. 덧셈 연산
    printf("\n=============  덧셈 검증 예시  ============== \n");
    int add_flag = BI_Add_xy(&num0, num1);
    
    // 1.1 덧셈 함수 연산 실패 시, 실패 메시지 출력 및 프로그램 종료
    if(add_flag != FUNC_SUCCESS) {
        puts("============= Add Fail ==============");
        return 0;
    } 
    // 1.2 덧셈 결과 값 출력
    printf("A + B = ");     bi_print_bigint_hex(num0);    printf("\n");

    // 2. BIGINT 변수 삭제
    bi_delete(&num0);

    // -------------------------------------------------------------------------------
    // Function 2. 뺄셈 갱신
    // -------------------------------------------------------------------------------
    // - 입력: (입력이자 뺄셈 결과를 저장할 BIGINT 구조체 더블 포인터 num0, 입력 BIGINT 포인터 num1)
    // - 출력: SUCCESS or ERROR CODE (int 변수로 반환값을 저장한 뒤, 에러 코드를 처리할 추가 코드 작성 필요)
    // -------------------------------------------------------------------------------
    
    // 0. BIGINT Set - 이전 연산에서 갱신되었으므로, 다시 Set
    set_flag_0 = bi_set_by_string(&num0, NON_NEGATIVE, "1234567890abcdef1234567890abcdef1234567890abcdef", HEXDECIMAL);
    
    // 0.1 유효하지 않은 입력이 발생할 경우 오류 메시지 출력 및 프로그램 종료
    if(set_flag_0 == INVALID_CHAR_ERROR) {
        puts("============= Input 1 : wrong! ==============");
        return 0;
    } 

    // 1. 뺄셈 연산
    printf("\n=============  뺄셈 검증 예시  ============== \n");
    int sub_flag = BI_Sub_xy(&num0, num1);
    
    // 1.1 뺄셈 함수 연산 실패 시, 실패 메시지 출력 및 프로그램 종료
    if(sub_flag != FUNC_SUCCESS) {
        puts("============= Sub Fail ==============");
        return 0;
    } 
    // 1.2 뺄셈 결과 값 출력
    printf("A - B = ");     bi_print_bigint_hex(num0);    printf("\n");

    // 2. BIGINT 변수 삭제
    bi_delete(&num0);

    // -------------------------------------------------------------------------------
    // Function 3. 곱셈 갱신
    // -------------------------------------------------------------------------------
    // - 입력: (입력이자 곱셈 결과를 저장할 BIGINT 구조체 더블 포인터 num0, 입력 BIGINT 포인터 num1)
    // - 출력: SUCCESS or ERROR CODE (int 변수로 반환값을 저장한 뒤, 에러 코드를 처리할 추가 코드 작성 필요)
    // -------------------------------------------------------------------------------
    
    // 0. BIGINT Set - 이전 연산에서 갱신되었으므로, 다시 Set
    set_flag_0 = bi_set_by_string(&num0, NON_NEGATIVE, "1234567890abcdef1234567890abcdef1234567890abcdef", HEXDECIMAL);
    
    // 0.1 유효하지 않은 입력이 발생할 경우 오류 메시지 출력 및 프로그램 종료
    if(set_flag_0 == INVALID_CHAR_ERROR) {
        puts("============= Input 1 : wrong! ==============");
        return 0;
    } 

    // 1. 곱셈 연산
    printf("\n=============  곱셈 검증 예시  ============== \n");
    int mul_flag = BI_Mul_xy(&num0, num1);
    
    // 1.1 곱셈 함수 연산 실패 시, 실패 메시지 출력 및 프로그램 종료
    if(mul_flag != FUNC_SUCCESS) {
        puts("============= Mul Fail ==============");
        return 0;
    } 
    // 1.2 곱셈 결과 값 출력
    printf("A * B = ");     bi_print_bigint_hex(num0);    printf("\n");

    // 2. BIGINT 변수 삭제
    bi_delete(&num0);

    // -------------------------------------------------------------------------------
    // Function 4. 제곱 갱신
    // -------------------------------------------------------------------------------
    // - 입력: (입력이자 제곱 결과를 저장할 BIGINT 구조체 더블 포인터 num0)
    // - 출력: SUCCESS or ERROR CODE (int 변수로 반환값을 저장한 뒤, 에러 코드를 처리할 추가 코드 작성 필요)
    // -------------------------------------------------------------------------------
    
    // 0. BIGINT Set - 이전 연산에서 갱신되었으므로, 다시 Set
    set_flag_0 = bi_set_by_string(&num0, NON_NEGATIVE, "1234567890abcdef1234567890abcdef1234567890abcdef", HEXDECIMAL);
    
    // 0.1 유효하지 않은 입력이 발생할 경우 오류 메시지 출력 및 프로그램 종료
    if(set_flag_0 == INVALID_CHAR_ERROR) {
        puts("============= Input 1 : wrong! ==============");
        return 0;
    } 

    // 1. 제곱 연산
    printf("\n=============  제곱 검증 예시  ============== \n");
    int sqr_flag = BI_Sqr_x(&num0);

    // 1.1 제곱 함수 연산 실패 시, 실패 메시지 출력 및 프로그램 종료
    if(sqr_flag != FUNC_SUCCESS) {
        puts("============= Sqr Fail ==============");
        return 0;
    } 
    // 1.2 제곱 결과 값 출력
    printf("A * A = ");     bi_print_bigint_hex(num0);    printf("\n");

    // 2. BIGINT 변수 삭제
    bi_delete(&num0);

    // -------------------------------------------------------------------------------
    // Function 5. 모듈러 갱신
    // -------------------------------------------------------------------------------
    // - 입력: (입력이자 모듈러 결과를 저장할 BIGINT 구조체 더블 포인터 num0 (나눠지는 수), 입력 BIGINT 포인터 num1 나눌 수)
    // - 출력: SUCCESS or ERROR CODE (int 변수로 반환값을 저장한 뒤, 에러 코드를 처리할 추가 코드 작성 필요)
    // -------------------------------------------------------------------------------
    
    // 0. BIGINT Set - 이전 연산에서 갱신되었으므로, 다시 Set
    set_flag_0 = bi_set_by_string(&num0, NON_NEGATIVE, "1234567890abcdef1234567890abcdef1234567890abcdef", HEXDECIMAL);
    
    // 0.1 유효하지 않은 입력이 발생할 경우 오류 메시지 출력 및 프로그램 종료
    if(set_flag_0 == INVALID_CHAR_ERROR) {
        puts("============= Input 1 : wrong! ==============");
        return 0;
    } 

    // 1. 모듈러 연산
    printf("\n=============  모듈러 검증 예시  ============== \n");
    int mod_flag = BI_Mod_xy(&num0, num1);

    // 1.1 모듈러 함수 연산 실패 시, 실패 메시지 출력 및 프로그램 종료
    if(mod_flag != FUNC_SUCCESS) {
        puts("============= Mod Fail ==============");
        return 0;
    } 
    // 1.2 모듈러 결과 값 출력
    printf("나머지 r = ");     bi_print_bigint_hex(num0);     printf("\n");

    // 2. BIGINT 변수 삭제
    bi_delete(&num0);

    // -------------------------------------------------------------------------------
    // (line 8) 2. main 함수 제일 마지막에 Set해준 BIGINT 변수 삭제
    // -------------------------------------------------------------------------------
    bi_delete(&num1);

    return 0;
}